###################################################################
1.1: OBJECTIVE
###################################################################

~

###################################################################
1.2: GETTING STARTED
###################################################################

~

###################################################################
1.3: WHAT IS COMPUTER SCIENCE?
###################################################################

The study of finding solutions using computational structures.

###################################################################
1.4: WHAT IS PROGRAMMING?
###################################################################

A method to implement our solutions.

###################################################################
1.5: WHY STUDY DATA STRUCTURES AND ABSTRACT DATA TYPES
###################################################################

Abstract data types (ADT) is a logical description of how we view 
    interface vs the implementation.
I use a car, but I don't know what goes on in the car, all I care
    for is that the car works which makes it an abstract data type.
Implementation of ADTs are referred to as data structures.
Data structures is a way to organize data.

To manage the complexity of problems and the problem-solving process.
Focus on the "big" instead of the "small", data abstraction.
Levels of abstraction means creating an encapsulation.
The users see one thing while developers see another.
Since there are different ways to implement ADTs this gives flexibility 
    to the developer without harming the user.
The user can remain focused on the problem-solving process.

###################################################################
1.6: WHY STUDY ALGORITHMS?
###################################################################

Algorithm is a type of solution.

By considering different algorithms and different problems, when
    we see a similar problem arise, we know which weapon to use.
We consider time and space complexities:
    What if we only have 2 minutes to compute? (Time)
    What if we give a problem 1000000 inputs? (Space)
Worst case scenario is that we have a problem that can't be solved
    or where solutions do exist but require too much time or other
    resources to work reasonably.
We find solutions and choose the correct one depending on the situation.

###################################################################
1.7: REVIEW OF BASIC PYTHON
###################################################################

Python is a modern, easy-t-learn, object-oriented programming language.
Built-in data types and easy-to-use control constructs.

###################################################################
1.8: GETTING STARTED WITH DATA
###################################################################

Define a class to be a description of what the data will look like
    (the state) and what the data can do (the behavior).
Classes are analogous to ADTs because a user of a class only sees 
    the state and behavior.
Data items are called objects in the object-oriented paradigm.
An object is an instance of a class.

###################################################################
1.8.1: BUILT-IN ATOMIC DATA TYPES
###################################################################

Atomic data types:
    int
    float
    bool

###################################################################
1.8.2: BUILT-IN COLLECTION DATA TYPES
###################################################################

Collection data types:
    lists               []
    strings             ""
    tuples              ()
    sets                {}
    dictionaries

List is an ordered collection. (Array)

Table of operations to use on lists.

OPERATION       OPERATOR    EXPLANATION

indexing 	    [ ] 	    Access an element of a sequence
concatenation 	+ 	        Combine sequences together
repetition 	    * 	        Concatenate a repeated number of times
membership 	    in 	        Ask whether an item is in a sequence
length 	        len 	    Ask the number of items in the sequence
slicing 	    [ : ] 	    Extract a part of a sequence

EXAMPLE:            YIELDS:

myList = [1,2,3,4]
A = [myList]*3
print(A)            [[1, 2, 3, 4], [1, 2, 3, 4], [1, 2, 3, 4]]
myList[2]=45
print(A)            [[1, 2, 45, 4], [1, 2, 45, 4], [1, 2, 45, 4]]

Table of methods to use on lists.

METHOD      USE                     EXPLANATION

append 	    alist.append(item) 	    Adds a new item to the end of a list
insert 	    alist.insert(i,item) 	Inserts an item at the ith position in a list
pop 	    alist.pop() 	        Removes and returns the last item in a list
pop 	    alist.pop(i) 	        Removes and returns the ith item in a list
sort 	    alist.sort() 	        Modifies a list to be sorted
reverse 	alist.reverse() 	    Modifies a list to be in reverse order
del 	    del alist[i] 	        Deletes the item in the ith position
index   	alist.index(item) 	    Returns the index of the first occurrence of item
count   	alist.count(item) 	    Returns the number of occurrences of item
remove  	alist.remove(item) 	    Removes the first occurrence of item

EXAMPLE:                        YIELDS:

myList = [1024, 3, True, 6.5]
myList.append(False)
print(myList)                   [1024, 3, True, 6.5, False]
myList.insert(2,4.5)
print(myList)                   [1024, 3, 4.5, True, 6.5, False]
print(myList.pop())             False
print(myList)                   [1024, 3, 4.5, True, 6.5]
print(myList.pop(1))            [1024, 4.5, True, 6.5]
print(myList)                   [1024, 4.5, True, 6.5, False]
myList.pop(2)
print(myList)                   [1024, 4.5, 6.5]  
myList.sort()
print(myList)                   [4.5, 6.5, 1024]     
myList.reverse()
print(myList)                   [1024, 6.5, 4.5]
print(myList.count(6.5))        1
print(myList.index(4.5))        2
myList.remove(6.5)
print(myList)                   [1024, 4.5]
del myList[0]
print(myList)                   [4.5]

Range function is used with lists.
Note that the second parameter usually is the end point
    (range doesn't touch it)

EXAMPLE:                        YIELDS:

range(10)                       range(0, 10)
list(range(10))                 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
range(5,10)                     range(5, 10)
list(range(5,10))               [5, 6, 7, 8, 9]
list(range(5,10,2))             [5, 7, 9]
list(range(10,1,-1))            [10, 9, 8, 7, 6, 5, 4, 3, 2]

Strings are collections of characters annotated by "".

EXAMPLE:                        YIELDS:

"David"                         "David"
myName = "David"                
myName[3]                       "i"
myName * 2                      "myNamemyName"
len(myName)                     5

Since strings are sequences, they work as expected.

EXAMPLE:                        YIELDS:

myName                          "David"
myName.upper()                  "DAVID"
myName.center(10)               "  David   "
myName.find('v')                2
myName.split('v')               ["Da","id"]

Split is useful for processing data by returning a list of strings.
    (If no division is specified for split, whitespace is used)

METHOD 	USE 	                EXPLANATION

center 	astring.center(w) 	    Returns a string centered in a field of size w
count 	astring.count(item) 	Returns the number of occurrences of item in the string
ljust 	astring.ljust(w) 	    Returns a string left-justified in a field of size w
lower 	astring.lower() 	    Returns a string in all lowercase
rjust 	astring.rjust(w) 	    Returns a string right-justified in a field of size w
find 	astring.find(item) 	    Returns the index of the first occurrence of item
split 	astring.split(schar) 	Splits a string into substrings at schar

Major difference between lists and strings is:
    lists can be modified
    strings can't
This is referred to as mutability.
    lists are mutable
    strings are immutable

EXAMPLE:        YIELDS:

myName          "David"
myName[0]="X"   !ERROR!

Tuples are similar to lists in that they are sequences of data.
Difference is that tuples are immutable, like a string.
(Sometimes you have to convert things to lists then revert back)
So why use tuples? 
    If you want constant immutable data, like coordinates.

A set is an unordered collection of zero or more immutable data objects.
Sets don't allow duplicates and are separated by commas in curly braces.
The set is mutable, you can remove or add, but you can not change.
Sets organize by data types, but indexing does not matter.

EXAMPLE:                        YIELDS:

{3,6,"cat",4.5,False}           {False, 4.5, 3, 6, 'cat'}
mySet = {3,6,"cat",4.5,False}
mySet                           {False, 4.5, 3, 6, 'cat'}

OPERATION	OPERATOR          	EXPLANATION

membership 	in 	                Set membership
length 	    len 	            Returns the cardinality of the set
| 	        aset | otherset 	Returns a new set with all elements from both sets
& 	        aset & otherset 	Returns a new set with only those elements common to both sets
- 	        aset - otherset 	Returns a new set with all items from the first set not in second
<= 	        aset <= otherset 	Asks whether all elements of the first set are in the second

Sets have methods that should be familiar in a mathematical setting.

METHOD	        USE 	                        EXPLANATION
union 	        aset.union(otherset) 	        Returns a new set with all elements from both sets
intersection 	aset.intersection(otherset) 	Returns a new set with only those elements common to both sets
difference 	    aset.difference(otherset) 	    Returns a new set with all items from first set not in second
issubset 	    aset.issubset(otherset) 	    Asks whether all elements of one set are in the other
add 	        aset.add(item) 	                Adds item to the set
remove 	        aset.remove(item) 	            Removes item from the set
pop 	        aset.pop() 	                    Removes an arbitrary element from the set
clear 	        aset.clear() 	                Removes all elements from the set